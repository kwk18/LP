# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Чурсина Н.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

В результате выполнения курсового проекта я получу навык отладки программ на языке Пролог, изучу его принципы и механизмы. Так же, освежу в памяти методику создания парсера.

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: ...
 3. Реализовать предикат проверки/поиска .... 
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## 1. Получение родословного дерева

С помощью инструментов на сайте www.myheritage.com я создала свое дерево. Следующим шагом был экспорт моего дерева в формат GEDCOM, что тоже было достаточно легко сделать с помощью данного сайта. 

## 2. Конвертация родословного дерева
Программе на вход подается файл "familytree.ged", который далее обрабатывается.
Каждая строка файла делится на несколько подстрок с помощью функции split().При этом рассматриваются только те строки, в которых есть 3 слова или больше.
Запоминаем вторую подстроку, чтобы понять, какое это поле ( нас интересуют только поля "GIVN", "SURN", "HUSB", "WIFE" и "CHIL"). 

```python
first = m[1]
```

В зависимости от полученного поля,каждая подстрока записывается каждый раз в список, предназначенный для нее. Например:

```python
 if first == "SURN":
            surname = m[2]
            curr = (name[:-1], surname[:-1])
            upd = {i:curr}
            s.update(upd)
```
Для разработки парсера я решила использовать Python, поскольку остальные языки программирования, которые я знаю, не так хорошо подходят для этой задачи. Парсер на С++ выглядел бы несколько сложнее, чем на Python.


## 3. Предикат поиска родственника
Исходный код:
```prolog
mother_in_law(Husband, X) :-
	parent(Husband, Y),
	parent(Wife, Y),
	sex(Wife, f),
	parent(X, Wife),!,
	sex(X, f).
```
В первых трех строчках находим сначала жену, в остальных - ищем мать жены.
Протокол работы:
```prolog

?- mother_in_law('Vladimir Skorikov', X).
X = 'Maria Ivanova'.

```


## 4. Определение степени родства

Решение данной задачи можно разбить на две подзадачи: 
1) вычисление степени родства близких родственников: мать, отец, брат, сестра, сын, дочь, муж, жена.
2) вычисление степени родства дальних родственников:

Первая подзадача решается следующим образом: 
```prolog
check(son, Parent, Child) :-
    	parent(Parent, Child),
	sex(Child, m).

check(daughter, Parent, Child) :-
	parent(Parent, Child),
	sex(Child, f).
	
check(husband, Wife, Husband) :-
   	parent(Husband, X),
	sex(Husband, m),
	parent(Wife, X),
	sex(Wife, f).

check(wife, Husband, Wife) :-
   	parent(Husband, X),
	sex(Husband, m),
	parent(Wife, X),
	sex(Wife, f).

check(father, Child, Father) :-
 	parent(Father, Child),
    	sex(Father, m).

check(mother, Child, Mother) :-
    	parent(Mother, Child),
    	sex(Mother, f).

check(brother, Child1, Child2) :-
	parent(P, Child1),!,
	parent(P, Child2),
	Child1 \= Child2,
	sex(Child2, m).
	
check(sister, Child1, Child2) :-
	parent(P, Child1),!,
	parent(P, Child2),
	Child1 \= Child2,
	sex(Child2, f).	
	
relative(Relation, X1, X2) :-
	check(Relation, X1, X2),!.	
```
Вторая подзадача решается следующим образом: 
```prolog
move(X,Y):-
    check(_,X,Y).
	
prolong([X|T],[Y,X|T]):-
	move(X,Y),
	not(member(Y,[X|T])). %добавление элемента в начало списка
	
bfs([[Finish|Tail]|_],Finish,[Finish|Tail]). 
bfs([TempWay|OtherWays],Finish,Way):-  
findall(W,prolong(TempWay,W),Ways),  % ищет все подходящие W и составляет список Ways
    append(OtherWays,Ways,NewWays), !, % объединение списков
    bfs(NewWays,Finish,Way).

	
find_relation([_], Pr, Pr).
find_relation([X,Y|T], Pr, Relation) :-
    check(Relate, X, Y),
    find_relation([Y|T], [Relate|Pr], Relation). % проверка и составление всего списка

relative(Relation, X1, X2) :-
    bfs([[X1]], X2, R),
	reverse(R, Rel),
	write(Rel), nl,
	find_relation(Rel, [], Relation1),
	reverse(Relation1, Relation).
```
Для решения второй подзадачи мы используем поиск в ширину. Он обладает следующим преимуществом: первым ищет самый короткий путь.

Протокол работы:
```prolog

?- relative(X,'Vladimir Skorikov','Natalia Skorikova').
X = daughter.

?- relative(X,'Natalia Chursina','Irina Skorikova').
X = mother.
```

## 5. Естественно-языковый интерфейс

## Выводы

Проделанная мной курсовая работа заставила задуматься о том, какие задачи решаются эффективно с помощью языка Prolog. Я неплохо освоила этот язык программирования, тем самым открыв что-то новое и интересное для себя. 


