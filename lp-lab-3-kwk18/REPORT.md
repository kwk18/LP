#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Чурсина Наталья Алексеевна

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|    30.11     |     4         |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

Какие задачи удобным образом решаются методом поиска в пространстве состояний?
Почему Prolog оказывается удобным языком для решения таких задач?

Многие логические задачи решаются этим методом. Поскольку изначально в задачах заданы лишь начальное и конечное условия,то нужно найти порядок действий, переводящих начальное условие в требуемое ( конечное ). Пространство состояний возникает как раз при разбиении решения задачи на отдельные шаги. Чтобы эффективно справиться с переходом от начального условия к конечному, используют именно такой метод.

## Задание
Вариант 4
Площадь разделена на шесть квадратов, пять из них заняты мебелью, шестой - свободен. Переставить мебель так, чтобы шкаф и кресло поменялись местами, при этом никакие два предмета не могут стоять на одном квадрате.

## Принцип решения

Согласно алгоритму, нам необходимо проинициализировать состояния и их изменения.
Проанализируем нашу задачу с целью получения информациции о конфигурациях и их изменениях:

1)

n B C D E F - >  B n C D E F

n B C D E F - >  D B C n E F

2)

A n C D E F - > A C n D E F

A n C D E F - > n A C D E F

A n C D E F - > A E C D n F

3)

A B n D E F - > A n B D E F

A B n D E F - > A B F D E n

4)

A B C n E F - > n B C A E F

A B C n E F - > A B C E n F

5)

A B C D n F - > A n C D B F

A B C D n F - > A B C n D F

A B C D n F - > A B C D F n

6)

A B C D E n - > A B C D n E

A B C D E n - > A B n D E C

**Формализование вышеизложенного на Prolog:**

```prolog
move([n,B,C,D,E,F],[B,n,C,D,E,F]).
move([n,B,C,D,E,F],[D,B,C,n,E,F]).

move([A,n,C,D,E,F],[A,C,n,D,E,F]).
move([A,n,C,D,E,F],[n,A,C,D,E,F]).
move([A,n,C,D,E,F],[A,E,C,D,n,F]).

move([A,B,n,D,E,F],[A,n,B,D,E,F]).
move([A,B,n,D,E,F],[A,B,F,D,E,n]).

move([A,B,C,n,E,F],[n,B,C,A,E,F]).
move([A,B,C,n,E,F],[A,B,C,E,n,F]).

move([A,B,C,D,n,F],[A,n,C,D,B,F]).
move([A,B,C,D,n,F],[A,B,C,n,D,F]).
move([A,B,C,D,n,F],[A,B,C,D,F,n]).

move([A,B,C,D,E,n],[A,B,C,D,n,E]).
move([A,B,C,D,E,n],[A,B,n,D,E,C]).
```
**Алгоритм поиска в глубину:**
```prolog
dfs([Finish | Tail], Finish, [Finish | Tail]).
dfs(TempWay, Finish, Way):-
prolong(TempWay, NewWay),
dfs(NewWay, Finish, Way).

prolong([X|T],[Y,X|T]):-
move(X,Y),
not(member(Y,[X|T])).

get_dfs(Start,Finish):- dfs([Start], Finish, Way), get_answer(Way).
```
Предикат prolong отвечает за переход от состояния к состоянию, предостерегая нас от зацикливания(не позволяет перейти в состояние, в котором мы уже были).

Предикат dfs отвечает за поиск в глубину, уходит в рекурсию после того, как отработал prolong, останавливается, когда текущая вершина
совпадает с конечной.

Предикат get_dfs необходим для запуска нахождения решения с помощью алгоритма поиска в глубину

**Алгоритм поиска в ширину:**
```prolog
bfs([[Finish|Tail]|_],Finish,[Finish|Tail]).
bfs([TempWay|OtherWays],Finish,Way):-
findall(W,prolong(TempWay,W),Ways),
append(OtherWays,Ways,NewWays),
bfs(NewWays,Finish,Way).

prolong([X|T],[Y,X|T]):-
move(X,Y),
not(member(Y,[X|T])).

```
Предикат findall(W,prolong(TempWay,W),Ways) отвечает за нахождение всех способов, с помощью которых можно продвнитуься из текущего состояния

Прекдикат append(OtherWays,Ways,NewWays) отвечает за добавление всех этих способов в конец списка путей.

Предикат bfs отвечает за поиск в ширину, уходит в рекурсию после выполнения предыдущих предикатов, завершается, когда текущая вершина совпадает с конечной.

Предикат get_bfs необходим для запуска нахождения решения с помощью алгоритма поиска в глубину

**Алгоритм поиска в глубину с итеративным погружением:**
```prolog
generate_d(1).
generate_d(N):-generate_d(M), N is M + 1.


id([Finish | Tail], Finish, [Finish | Tail], 0).
id(TempWay, Finish, Way, N):-
N > 0,
prolong(TempWay, NewWay),
N1 is N - 1,
id(NewWay, Finish, Way, N1).

get_id(A,B) :- generate_d(DL), id([A],B,P,DL), get_answer(P).
```
Предикат generate_d отвечает за генерациию максимальной глубины поиска

Предикат id  отвечает за поиск в глубину с итеративным погружением (немного измененный dfs)

Предикат get_id необходим для запуска нахождения решения с помощью алгоритма поиска в глубину с итеративным погружением.


Предикат get_answer отвечает за читабельный вывод
```prolog
get_answer([X]):-write(X),!.
get_answer([A,B|Tail]):-
get_answer([B|Tail]),
nl,
write(A).
```

Для хронометрирования алгоритмов использована библиотека :- use_module(library(statistics)).


## Результаты

| Алгоритм поиска     | Длина найденного первым пути         |  Время    |
|-------------------------|----------------------------------------------|------------|
| В глубину                  |                  163                                        |  23 msec |
| В ширину                  |                  19                                          |  75 msec |
|             ID                   |                  19                                          | 34 msec  |



## Выводы

Сформулируйте *содержательные* выводы по лабораторной работе.

Я познакомилась с методом поиска в пространстве состояний. Для решения данной задачи я применяла два алгоритма поиска : в глубину и в ширину. Из полученной таблицы можно сделать вывод о том, что алгоритм поиска в ширину работает дольше, чем алгоритм поиска в глубину.

