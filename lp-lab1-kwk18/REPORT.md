# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Чурсина Н.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение


Список в языке Prolog представлен как двоичное дерево. В его листьях располагаются объекты - элементы списка или, если их нет, то список называется пустым. Если список не пустой, то он формируется из двух частей - головы и хвоста. 
Конечно, список в империтвных языках и список в Prolog , это разные списки. Главное отличие, по моему мнениею, заключается в том, что в Prolog обрабатывать элементы списка можно только с помощью рекурсии, а в императивных языках можно использовать итераторы. 
Мне кажется, что списки в Prolog чем-то похожи на привычные нам массивы.

## Задание 1.1: Предикат обработки списка
Вариант 9.

`get_Num(N,L,X)` - получение n-ого элемента списка ( с использованием стандартных предикатов)

Примеры использования:
```prolog
?- get_Num(2,[0,1,2],X).
X = 1 .

?- get_Num(6,[66,2,3,6,7,2,5,4,5,3,2],X).
X = 2 .
```

Реализация:
```prolog
get_Num(N,L,X):-
my_append(A,[X|_],L),
my_length(A,N1),
N is N1+1.
```
Используя предикат append убираем из исходного списка элемент длиной N-1.

`getNum(N,[_|L],X)` - получение n-ого элемента списка ( без стандартных предикатов )

Примеры использования:
```prolog
?- getNum(6,[66,2,3,6,7,2,5,4,5,3,2],X).
X = 2 .

?- getNum(2,[0,1,2],X).
X = 1 .
```

Реализация:
```prolog
getNum(1,[Y|_],Y).
getNum(N,[_|L],X):-
getNum(N1,L,X),
N is N1+1.
```
С помощью рекурсии обрабатываем список, число N уменьшается, пока не станет = 1.



## Задание 1.2: Предикат обработки числового списка

Вариант 13.

`isArifm([A,B|T],D)` - проверка на арифметическую прогрессию, если известна разность прогрессии D
`isArifm(L)` - проверка прогрессии с неизвестной разностью

Примеры использования:
```prolog
?- isArifm([1,3,5],2).
true .

?- isArifm([1,3,5],4).
false.
```

Реализация:
```prolog
%Проверка прогрессии с неизвестной разностью:
isArifm(L):-
isArifm(L,_).

%Проверка с известной разностью прогрессии:
isArifm([],_).
%список с одним элементом
isArifm([_],_).
%список с несколькими элементами
%для сравнения необходимо хотя бы два элемента
isArifm([A,B|T],D):-
D is B-A,
isArifm([B|T],D).
```
Проверяем прогрессию через разность прогрессии D.


## Задание 2: Реляционное представление данных
Вариант 2.
Реляционное представление показывает взаимоотношения объектов. Чтобы работать с таким представлением, нужно грамотно его реализовать. 
1.Напечатать средний балл для каждого предмета.

`aMark(Subject,Mark)`  - печатает средний балл по каждому предмету

Протокол работы:
```prolog
| ?- aMark('Психология',X).
X = 3.8571428571428572

| ?- aMark('Математический анализ',X).
X = 4.0357142857142856

```
Реализация:
```prolog
%Сумма всех оценок по предмету:
sumOfGrades([],0).
sumOfGrades([grade(X,Y)|L],N):-
sumOfGrades(L,M),
N is Y + M.

%Средний балл по каждому предмету:
aMark(Subject,Mark):-
subject(Subject,Y),
length(Y, L),
sumOfGrades(Y, S),
Mark is S / L.
```
Считаем сумму всех оценок по предмету, далее считаем средний балл ( S / L), где S- сумма, L - количество оценок.

3.Найти количество несдавших студентов для каждого из предметов

`didNotPassSub(S,N)` - находит количество несдавших студентов по предмету

Протокол работы:
```prolog
| ?- didNotPassSub('Психология',X).
X = 2

| ?- didNotPassSub('Математический анализ',X).
X = 1

```
Реализация:
```prolog
%3.Найти количество несдавших по каждому предмету:

numDidNotPass([],0).
numDidNotPass([grade(X,Y)|L],N):-
Y < 3, !,
numDidNotPass(L,M),
N is M + 1.
numDidNotPass([_|L],N):-
numDidNotPass(L,N).

didNotPassSub(S,N):-
subject(S,Y),
numDidNotPass(Y,N).
```
Подсчет двоек в списке оценок для предмета.


## Выводы

Эта лабораторная работа научила меня тому, что лучше все делать вовремя и последовательно, а не в спешке. Ведь, чтобы решить такую программу, нужно составить так называемую логическую модель. Программа кажется простой и небольшой по объему, но для решения этой задачи мне потребовалось много времени. 




